[{"title":"区块链原理简介","date":"2018-03-14T09:41:42.000Z","path":"2018/03/14/区块链原理简介/","text":"区块链原理数字货币和区块链原理简介 数字货币：数字货币是基于数学加密原理构建的不可伪造的货币系统 比特币：第一个基于数学加密原理构建的去中心化分布式货币系统 历史： 2008年10月：加密学论坛发表了基于p2p协议来构建分布式加密数字货币系统的文章（比特币的白皮书） 2008年11月：比特币代码发布 2009年1月：中本聪挖出比特币第一个区块，创世区块 特征： 去中心化 不可伪造 分布式 可追溯 货币历史：物物交换、贝壳（急需一般等价物）、贵金属（冶炼技术发展）、纸币（金属沉重）、电子货币（方便） 法币由政府发行，强制推行流通；比特币全球p2p网络发行流通，无需中央节点；钱包节点把交易发送到网络，旷工节点把网络交易打包到区块链中，从中赚取挖矿的费用和手续费；比特币数量记录在全网总账本中（区块链），每个节点都复制完整的区块链数据 比特币网络运行机制： 用户创建交易并签名发送给P2P网络 矿工验证交易后将一批交易打包成新区块并获取挖矿奖励 其他节点验证并接受或拒绝该区块 每个新区快都指向前一个区块形成区块链 全网所有账户余额与全部历史交易记录都保存在区块链中 区块链记账原理 区块链就是一个不断增长的全网总账本 每个节点都拥有完整的区块链 节点总是信任最长的区块链 伪造区块链需要拥有超过51%的全网算力 安全哈希算法的特点 是一个单向函数，h=H(x) 通过输入可以很容易计算出输出 通过输出无法反推输入，只能暴力穷举 可以把任意长度的输入数据转化为固定长度的输出 碰撞率低，如果x!=y，而H(x)=H(y)，则发生碰撞 输出无规律，输入数据任意一个bit的改动会导致输出完全不同 比特币使用的哈希算法： SHA-256(理论碰撞概率，尝试2的130次方随机输入，有99.8%的概率碰撞，2的130次方=1361万亿亿亿亿) RipeMD 160 hash256 = sha256(sha256(data))hash160 = ripemd160(sha256(data)) 结论： 区块链依靠安全的哈希算法保证所有区块数据不可更改 工作量证明机制保证修改区块链的难度非常巨大从而无法实现 去中心化交易原理传统的电子交易需用通过银行这样的信任结构，保证交易的安全，不存在一方到账，一方没有付款的情况。 签名是为了确认某笔交易确实是由某个人做出的，比如在签合同的时候会通过笔迹来核对身份，计算机中是通过数字签名，私钥、公钥发消息方：message = “hello”signature = sign(message, SK)接消息方：verify(message, signature, PK) 数字签名的作用： 签名不可伪造 消息不可篡改 签名不可抵赖 常用的数字签名算法 RSA DSA ECDSA 比特币采用ECDSA算法 私钥是1~2的256次方随机数 公钥是由私钥根据ECDSA算法推算出来的 通过公钥无法反推私钥（只能暴力破解） 比特币钱包分类 本地钱包 在线钱包 纸钱包 脑钱包 钱包帮助用户保存私钥，私钥是一个256位的整数，用16进制表示也需要64个字符，为了在使用上方便，会使用一些编码方式让较少的字符就能表示私钥，具体不展开阐述。 结论： 比特币使用数字签名保证零信任可靠的P2P交易 私钥是花费比特币的唯一手段 钱包软件用来帮助用户管理私钥 所有交易被记录在区块链中，可以通过公钥来查询 比特币网络没有用户的概念，任何人都能通过公钥查询比特币余额，但却无法得知这串公钥是谁的 PoW机制与挖矿原理 挖矿定义 比特币网络中存在这样一些节点，它们试图把新的交易打包成新的区块，并附加的区块链上，这样的节点俗称矿工，每成功打包一个新区块，矿工就会获得奖励，这样的行为叫做挖矿。在挖矿完成后需要判断挖矿的奖金要给谁，这个的实现是矿工在打包区块的时候将奖金的发放写入交易列表，从而给矿工的地址添加相应奖金数量比特币。 挖矿原理：工作量证明（PoW：proof of work） 什么是工作量证明 证明自己做了一定工作量 其他人可以简单验证该工作量，从而认可你的工作 比特币用计算哈希作为矿工的工作证明，通过不断调整Nonce字段，计算出不同的哈希值，当满足哈希值&lt;难度值时，就是一个有效哈希，该区块就可作为一个有效区块写入区块链，并广播到其他节点。比特币会动态调整难度值，每2015个区块会调整一次，让新区块的生成速度保持在10分钟左右一个。 为什么别人无法窃取矿工的工作成果呢？ merkle hash锁定了该区块的所有交易 该区块的第一笔是矿工奖励的发放记录，收款地址是矿工的地址 比特币挖矿 比特币被限制总量约2100万个比特币 初始挖矿奖励为50个比特币每区块，每4年减半 结论： 比特币挖矿是一种带经济激励的工作量证明机制 工作量证明保证了修改区块链需要极大的成本 比特币网络的安全依靠算力来保证","tags":[]},{"title":"MySQL索引","date":"2017-06-22T03:20:17.000Z","path":"2017/06/22/mysql_index/","text":"索引定义MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。 数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 索引的分类 B-Tree 索引：最常见的索引类型，大部分引擎都支持B树索引。 HASH 索引：只有Memory引擎支持，使用场景简单。 R-Tree 索引(空间索引)：空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型。 Full-text (全文索引)：全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。 MyISAM、InnoDB引擎、Memory三个常用引擎类型比较 索引 MyISAM引擎 InnoDB引擎 Memory引擎 B-Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 支持 不支持 不支持 Full-Text索引 不支持 5.6版本后支持 不支持 B-Tree索引当人们谈论索引的时候，如果没有特别指明类型，那多半说的是B-Tree索引，它使用B-Tree数据结构来存储数据。大多数MySQL引擎都支持这种索引。Archive引擎是一个例外：5.1之前Archive不支持任何索引，直到5.1才开始支持单个自增列（AUTO_INCREMENT）的索引。 我们使用术语“B-Tree”，是因为MySQL在CREATETABLE和其他语句中也使用该关键字。不过，底层的存储引擎也可能使用不同的存储结构，例如，NDB集群存储引擎内部实际上使用了T-Tree结构存储这种索引，即使其名字是BTREE；InnoDB则使用的是B+Tree。 存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。 B-Tree索引的限制 如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。 不能跳过索引中的列。也就是说，前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名（first_name），则MySQL只能使用索引的第一列。 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询WHERElast_name=’Smith’ANDfrst_nameLIKE’J％’ANDdob=’1976-12-23’，这个查询只能使用索引的前两列，因为这里LIKE是一个范围条件（但是服务器可以把其余列用于其他目的）。如果范围查询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。在本章的索引案例学习部分，我们将演示一个详细的案例。 哈希索引哈希索引（hashindex）基于哈希表实现，只有精确匹配索引所有列的查询才有效(4)。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hashcode），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。 在MySQL中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。值得一提的是，Memory引擎是支持非唯一哈希索引的，这在数据库世界里面是比较与众不同的。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。 哈希索引的限制 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列（A,B）上建立哈希索引，如果查询只有数据列A，则无法使用该索引。哈希索引只支持等值比较查询，包括=、IN()、&lt;=&gt;（注意&lt;&gt;和&lt;=&gt;是不同的操作）。也不支持任何范围查询，例如WHEREprice&gt;100。 访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低（哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。 B-Tree索引+哈希索引InnoDB引擎有一个特殊的功能叫做“自适应哈希索引（adaptivehashindex）”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。 创建自定义哈希索引。如果存储引擎不支持哈希索引，则可以模拟像InnoDB一样创建哈希索引，这可以享受一些哈希索引的便利，例如只需要很小的索引就可以为超长的键创建索引。 思路很简单：在B-Tree基础上创建一个伪哈希索引。这和真正的哈希索引不是一回事，因为还是使用B-Tree进行查找，但是它使用哈希值而不是键本身进行索引查找。你需要做的就是在查询的WHERE子句中手动指定使用哈希函数。 索引的优点 索引大大减少了服务器需要扫描的数据量。 索引可以帮助服务器避免排序和临时表。 索引可以将随机I/O变为顺序I/O。","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"基础邮件协议","date":"2015-01-27T04:43:23.000Z","path":"2015/01/27/mail_protocol/","text":"SMTP SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）定义了邮件客户端与SMTP服务器之间，以及两台SMTP服务器之间的通信规则。SMTP协议的通信双方采用一问一答的命令/响应形式进行对话,SMTP协议定义了对话的规则和所有命令/响应的语法格式。SMTP协议分为标准SMTP协议和扩展SMTP协议（ESMTP，Extension Simple Mail Transfer Protocol），标准SMTP协议是1982年在RFC821文档中定义的，而扩展SMTP协议是1995年在RFC1869文档中定义的。扩展SMTP协议在标准SMTP协议基础上的改动非常小，主要增加了邮件安全方面的认证功能，人们现在所说的SMTP协议基本上都是指扩展SMTP协议。 SMTP服务器默认的网络监听端口号为25，协议中一共定义了18条命令，发出一封电子邮件的过程通常只需要使用其中的6条命令。下表列出了这6条命令，并描述了其语法格式及功能说明，其中，&lt;SP&gt;代表空格，&lt;CRLF&gt;代表回车和换行。 SMTP命令及格式 说明 ehlo&lt;SP&gt;&lt;domain&gt;&lt;CRLF&gt; ehlo命令是SMTP邮件发送程序与SMTP邮件接收程序建立连接后必须发送的第一条SMPT命令，参数&lt;domain&gt;表示SMTP邮件发送者的主机名。ehlo命令用于替代传统SMTP协议中的helo命令。例：ehlo testname（主机名） auth&lt;SP&gt;&lt;para&gt;&lt;CRLF&gt; 如果SMTP邮件接收程序需要SMTP邮件发送程序进行认证时，它会向SMTP发送程序提示它所采用的认证方式，SMTP邮件发送程序接着应该使用这个命令回应SMTP邮件接收程序，参数表示回应的认证方式，通常是SMTP邮件接收程序先前提示的认证方式。例：auth login（以login方式验证） mail&lt;SP&gt;From:&lt;reverse-path&gt;&lt;CRLF&gt; 此命令用于指定邮件发送者的邮箱地址，参数&lt;reverse-path&gt;表示发件人的邮箱地址。例：mail From:&#116;&#101;&#x73;&#x74;&#x31;&#64;&#115;&#x69;&#x6e;&#x61;&#x2e;&#x63;&#x6f;&#x6d; rcpt&lt;SP&gt;To:&lt;forword-path&gt;&lt;CRLF&gt; 此命令用于指定邮件接收者的邮箱地址，参数&lt;forword-path&gt;表示接收者的邮件地址。如果邮件要发送给多个接收者，那么应使用多条rcpt&lt;SP&gt;To命令来分别指定每一个接收者的邮箱地址。例：rcpt To:&#116;&#x65;&#x73;&#x74;&#x32;&#64;&#x73;&#105;&#x6e;&#97;&#46;&#x63;&#x6f;&#x6d; data&lt;CRLF&gt; 此命令用于表示SMTP邮件发送程序准备开始传送邮件内容，在这个命令后面发送的所有数据将被当做邮件内容，直至遇到&lt;CRLF&gt;.&lt;CRLF&gt;标识符，则表示邮件内容结束。 quit&lt;CRLF&gt; 此命令表示要结束邮件发送过程，SMTP邮件接受程序接收到此命令后，将关闭与SMTP邮件发送程序的网络连接。 POP3 POP3（Post Office Protocol - Version 3，邮局协议版本3）是TCP/IP协议族中的一员，由RFC1939 定义。本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。提供了SSL加密的POP3协议被称为POP3S。 POP 协议支持“离线”邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是PC机或 MAC。一旦邮件发送到 PC 机或MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。 POP3协议采用的网络监听端口号默认为110，协议中共定义12条POP3命令，邮件客户端通过这些命令来检索和获取用户电子邮箱中的邮件信息。下表列出了这12条命令。 命令 参数 状态 描述 USER username 认可 username表示收件人的账号名称，此命令与下面的pass命令若成功，将导致状态转换 PASS password 认可 password表示收件人账户的密码 APOP Name,Digest 认可 用于替代user和pass命令，它以MD5数字摘要的形式向POP3邮件服务器提交账户密码 STAT None 处理 请求服务器发回关于邮箱的统计，如邮件总数和总字节数 UIDL [Msg#] 处理 返回邮件的唯一标识符，POP3会话的每个标识符都是唯一的，参数msg#表示邮件的序号 LIST [Msg#] 处理 列出邮箱中的邮件信息（包括邮件数量和每个邮件的大小），若参数msg#指定时，列出具体序号的邮件信息 RETR [Msg#] 处理 返回由参数标识的邮件的全部文本 DELE [Msg#] 处理 服务器将由参数标识的邮件标记为删除，由quit命令执行 RSET None 处理 服务器将重置所有标记为删除的邮件，用于撤消DELE命令 TOP [Msg#] 处理 服务器将返回由参数标识的邮件前n行内容，n必须是正整数 NOOP None 处理 服务器返回一个肯定的响应，用于检测POP3客户端与POP3服务器的连接情况 QUIT None 更新 退出并删除所有设置了删除标志的邮件 IMAP IMAP（Internet Message Access Protocol）协议是对POP3协议的一种扩展，定义了邮件客户端与邮件服务器的通信规则。IMAP协议在RFC2060文档中定义，目前使用的是第4个版本，所以也称之为IMAP4。IMAP协议相对于POP3协议而言，它定义了更为强大的邮件接收功能，主要体现在以下一些方面： IMAP具有摘要浏览功能，可以让用户在读完所有邮件的主题、发件人、大小等信息后，再由客户做出是否下载或直接在服务器上删除的决定。 IMAP可以让用户有选择性地下载邮件附件。例如一封邮件包含3个附件，如果用户确定其中只有2个附件对自己有用，就可以只下载这2个附件，而不必下载整封邮件，从而节省了下载时间。 IMAP可以让用户在邮件服务器上创建自己的邮件夹，保存各个邮件。 MIME MIME（Multipurpose Internet Mail Extensions,多用途互联网邮件扩展类型）是目前互联网电子邮件普遍遵循的邮件技术规范。在MIME出现之前，互联网电子邮件主要遵循由RFC 822所制定的标准，电子邮件一般只用来传递基本的ASCII码文本信息，MIME在 RFC 822的基础上对电子邮件规范做了大量的扩展，引入了新的格式规范和编码方式，在MIME的支持下，图像、声音、动画等二进制文件都可方便的通过电子邮件来进行传递，极大地丰富了电子邮件的功能。目前互联网上使用的基本都是遵循MIME规范的电子邮件。 电子邮件的分析和读取一般都通过专用的邮件软件来实现，比如Outlook、Foxmail，但这种第三方软件无法和开发者自己的系统整合，通过对MIME邮件格式的分析，我们可以在自己的应用程序中实现对MIME邮件所含信息的读取。 MIME邮件格式分析 &emsp;MIME技术规范的完整内容由RFC 2045-2049定义，包括了信息格式、媒体类型、编码方式等各方面的内容，这里我们只介绍其中的一些关键的格式和规范，通过了解这些格式规范，我们就可以实现以编程的方式从MIME邮件中提取基本的邮件信息。 域 &emsp;MIME邮件的基本信息、格式信息、编码方式等重要内容都记录在邮件内的各种域中，域的基本格式：{域名}：{内容}，域由域名后面跟“：”再加上域的信息内容构成，一条域在邮件中占一行或者多行，域的首行左侧不能有空白字符，比如空格或者制表符，占用多行的域其后续行则必须以空白字符开头。域的信息内容中还可以包含属性，属性之间以“;”分隔，属性的格式如下：{属性名称}=”{属性值}”。 &emsp;以下是一封示例邮件的内容，其中行1-5、行8都是单行的域，行6-7则是一个多行的域，并带有一个名为charset的属性，属性值为us-ascii。 12345678910From： ”suntao” &lt;suntao@fimmu.com&gt;To： &lt;yxj@fimmu.com&gt;Subject： hello worldDate： Mon， 9 Oct 2006 16：51：34 +0800MIME-Version： 1.0Content-Type： text/plain; charset=&quot;us-ascii&quot;Date： Mon， 9 Oct 2006 16：48：25 +0800Hello world &emsp;邮件规范中定义了大量域，分别用来存储同邮件相关的各种信息，比如发件人的名字和邮件地址信息存储在From域中，收件人的邮件地址信息存储在To域中，开发人员可通过查询RFC文档得到完整的邮件域定义列表。 Content-Type域 &emsp;Content-Type域定义了邮件中所含各种内容的类型以及相关属性。邮件所含的文本、超文本、附件等信息都按照对应Content-Type域所指定的媒体类型、存储位置、编码方式等信息存储在邮件中。Content-Type域基本格式：Content-Type：{主类型}/{子类型}。&emsp;示例邮件中的行6-7就是一个Content-Type域，主类型为text，子类型为plain，字符集属性为us-ascii。 主类型 常见属性 参数含义 text charset 文本信息所使用的字符集 image name 图像的名称 application name 应用程序的名称 multipart boundary 邮件分段边界标识 multipart类型&emsp;MIME邮件中各种不同类型的内容是分段存储的，各个段的排列方式、位置信息都通过Content-Type域的multipart类型来定义。multipart类型主要有三种子类型：mixed、alternative、related。 multipart类型基本格式 multipart/mixed类型&emsp;如果一封邮件中含有附件，那邮件的Content-Type域中必须定义multipart/mixed类型，邮件通过multipart/mixed类型中定义的boundary标识将附件内容同邮件其它内容分成不同的段。基本格式如下： Content-Type： multipart/alternative; boundary=&quot;{分段标识}&quot; multipart/alternative类型&emsp;MIME邮件中除了可以携带各种附件外，还可以将其它内容以内嵌资源的方式存储在邮件中。比如我们在发送html格式的邮件内容时，可能使用图像作为html的背景，html文本会被存储在alternative段中，而作为背景的图像则会存储在multipart/related类型定义的段中。基本格式如下： Content-Type： multipart/alternative; boundary=&quot;{分段标识}&quot; multipart/related类型&emsp; MIME邮件中除了可以携带各种附件外，还可以将其它内容以内嵌资源的方式存储在邮件中。比如我们在发送html格式的邮件内容时，可能使用图像作为html的背景，html文本会被存储在alternative段中，而作为背景的图像则会存储在multipart/related类型定义的段中。基本格式如下： Content-Type： multipart/related; type=&quot;multipart/alternative&quot;; boundary=&quot;{分段标识}&quot; multipart类型的boundary属性&emsp;multipart的子类型中都定义了各自的boundary属性，邮件使用这些boundary中定义的字符串作为标识，将邮件内容分成不同的段，段体内的每个子段以“–”+boundary行开始，父段则以“–”+boundary+“–”行结束，不同段之间用空行分隔。 multipart类型的层次关系&emsp;MIME邮件通过多个Content-Type域的multipart类型将内容分成不同的段，这些段在邮件中不是线形顺序排列的，而是存在一个互相包含的层次关系，multipart子类型之间的层次关系结构如下： Multipart/mixed Multipart/related Multipart/alternative纯文本正文超文本正文 内嵌资源 附件 参考资料：[1]Java邮件开发详解（张孝祥、方立勋编著）[2]pop3命令[3]MIME详解","tags":[{"name":"邮件协议","slug":"邮件协议","permalink":"http://yoursite.com/tags/邮件协议/"}]},{"title":"hello world","date":"2015-01-03T14:02:18.000Z","path":"2015/01/03/hello_world/","text":"Create a new file1234567#include&lt;iostream&gt;using namespace std;int main&#123; cout&lt;&lt;\"Hello World!\"&lt;&lt;endl; return 0;&#125; CompileBuildand Run## 1Really hello,the world!","tags":[{"name":"hello world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"}]}]